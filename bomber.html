<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stickman Bomber - Pro El Takibi</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Chosen Palette: SkyBlue, ForestGreen, Slate, Red -->
    <!-- Application Structure Plan: High-speed hand tracking with visible skeleton. Side walls for collision. Fragmentation physics for enemies. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. NO TTS used. -->

    <style>
        body { margin: 0; overflow: hidden; background: #87ceeb; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        canvas { display: block; }
        .video-input { visibility: hidden; position: absolute; }
        .camera-preview {
            position: absolute; top: 20px; right: 20px; width: 280px; height: 210px;
            border: 4px solid #fff; border-radius: 20px; background: #000;
            overflow: hidden; z-index: 50; box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        .camera-preview canvas { width: 100%; height: 100%; transform: scaleX(-1); }
        #loading-overlay {
            position: fixed; inset: 0; background: #0f172a;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; color: white;
        }
        .loader {
            border: 4px solid #1e293b; border-top: 4px solid #38bdf8;
            border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="loading-overlay">
        <div class="loader"></div>
        <h1 class="text-2xl font-bold mb-2">El Takip Sistemi Hazırlanıyor...</h1>
        <p class="text-sky-400 text-sm italic">Fizik motoru ve sesler yükleniyor.</p>
    </div>

    <video class="video-input"></video>
    <canvas id="gameCanvas"></canvas>

    <!-- UI Overlay -->
    <div class="absolute top-4 left-4 pointer-events-none">
        <div class="bg-white/80 backdrop-blur p-6 rounded-3xl shadow-2xl border border-white/50">
            <h2 class="text-3xl font-black text-slate-800 italic uppercase tracking-tighter">SEVİYE <span id="level-display">1</span></h2>
            <div class="mt-4 flex gap-6">
                <div class="text-center">
                    <p class="text-[10px] text-slate-500 uppercase font-black">BOMBALAR</p>
                    <p id="bomb-display" class="text-3xl font-black text-red-600">5</p>
                </div>
                <div class="text-center border-l border-slate-300 pl-6">
                    <p class="text-[10px] text-slate-500 uppercase font-black">HEDEFLER</p>
                    <p id="enemy-display" class="text-3xl font-black text-blue-600">3</p>
                </div>
            </div>
            <div id="tracking-ui" class="mt-4 p-2 rounded-xl bg-slate-100 flex items-center gap-3">
                <div id="status-dot" class="w-3 h-3 rounded-full bg-red-500"></div>
                <span id="status-text" class="text-[10px] font-bold text-slate-600 uppercase">EL BEKLENİYOR</span>
            </div>
        </div>
    </div>

    <div class="camera-preview">
        <canvas id="previewCanvas"></canvas>
    </div>

    <div id="game-modal" class="hidden fixed inset-0 bg-slate-900/60 z-50 flex items-center justify-center backdrop-blur-md">
        <div class="bg-white p-10 rounded-3xl text-center max-w-sm w-full mx-4 shadow-2xl border-t-8 border-blue-500">
            <h2 id="modal-title" class="text-4xl font-black mb-2 text-slate-800 uppercase">ZAFER!</h2>
            <p id="modal-desc" class="text-slate-500 mb-8 font-medium italic">Görevi başarıyla tamamladın.</p>
            <button id="modal-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-black py-4 px-10 rounded-2xl w-full transition transform hover:scale-105 shadow-lg active:scale-95">
                SONRAKİ SEVİYE
            </button>
        </div>
    </div>

    <script>
        /**
         * SES SİSTEMİ (Gerçek Sesler)
         */
        const sfx = {
            throw: new Audio('https://assets.mixkit.co/active_storage/sfx/2568/2568-preview.mp3'),
            explosion: new Audio('https://assets.mixkit.co/active_storage/sfx/2594/2594-preview.mp3'),
            impact: new Audio('https://assets.mixkit.co/active_storage/sfx/2571/2571-preview.mp3'),
            bounce: new Audio('https://assets.mixkit.co/active_storage/sfx/133/133-preview.mp3')
        };

        function playSFX(name) {
            const sound = sfx[name].cloneNode();
            sound.volume = 0.5;
            sound.play().catch(() => {});
        }

        /**
         * FİZİK MOTORU
         */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');
        const videoElement = document.querySelector('.video-input');

        const GRAVITY = 0.3;
        const FRICTION_X = 0.99;
        const FRICTION_Y = 0.6;
        const BOMB_FUSE = 2800;
        const MAX_ARM_RADIUS = 120;
        const WALL_BOUNCE = 0.75;

        let gameState = {
            level: 1, bombsLeft: 5,
            entities: [], particles: [], clouds: [], mountains: [],
            cameraShake: 0,
            handFound: false,
            isFist: false,
            grabStartPos: null, grabStartTime: 0,
            playerArmPos: { x: 0, y: 0 }
        };

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            previewCanvas.width = 320;
            previewCanvas.height = 240;
            initBG();
        }
        window.addEventListener('resize', resize);

        function initBG() {
            gameState.clouds = [];
            for(let i=0; i<8; i++) {
                gameState.clouds.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 0.35,
                    speed: 0.1 + Math.random() * 0.4,
                    size: 30 + Math.random() * 60
                });
            }
            gameState.mountains = [];
            for(let i=0; i<3; i++) {
                gameState.mountains.push({
                    x: i * (canvas.width / 2.5),
                    w: canvas.width * 0.6,
                    h: 150 + Math.random() * 120,
                    color: '#2d3436'
                });
            }
        }

        class Entity {
            constructor(x, y, type, color) {
                this.x = x; this.y = y;
                this.vx = 0; this.vy = 0;
                this.type = type; this.color = color;
                this.radius = 20; this.rotation = 0; this.rotVel = 0;
                this.isStatic = false; this.markedForDeletion = false;
            }
            update() {
                if (this.isStatic) return;
                this.vy += GRAVITY;
                this.x += this.vx; this.y += this.vy;
                this.rotation += this.rotVel;
                this.vx *= FRICTION_X;

                // Duvarlardan Sekme (Walls)
                if (this.x - this.radius < 0) {
                    this.x = this.radius; this.vx *= -WALL_BOUNCE;
                    if(this.type === 'bomb') playSFX('bounce');
                } else if (this.x + this.radius > canvas.width) {
                    this.x = canvas.width - this.radius; this.vx *= -WALL_BOUNCE;
                    if(this.type === 'bomb') playSFX('bounce');
                }

                // Zemin
                if (this.y + this.radius > canvas.height - 50) {
                    this.y = canvas.height - 50 - this.radius;
                    this.vy *= -FRICTION_Y;
                    this.vx *= 0.8;
                }
            }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
                if (this.type === 'player') this.drawPlayer(ctx);
                else if (this.type === 'stickman') this.drawEnemy(ctx);
                else if (this.type === 'bomb') this.drawBombShape(ctx);
                else if (this.type === 'piece') {
                    ctx.fillStyle = this.color; ctx.fillRect(-6, -6, 12, 12);
                }
                ctx.restore();
            }
            drawPlayer(ctx) {
                ctx.strokeStyle = this.color; ctx.lineWidth = 6; ctx.lineCap = 'round';
                ctx.beginPath(); ctx.arc(0, -25, 12, 0, Math.PI * 2); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, -13); ctx.lineTo(0, 15); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, 15); ctx.lineTo(-12, 38); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, 15); ctx.lineTo(12, 38); ctx.stroke();
                
                const armDx = gameState.playerArmPos.x - this.x;
                const armDy = gameState.playerArmPos.y - (this.y - 8);
                ctx.beginPath(); ctx.moveTo(0, -8); ctx.lineTo(armDx, armDy); ctx.stroke();
                
                if (gameState.isFist && gameState.handFound && gameState.bombsLeft > 0) {
                    ctx.save(); ctx.translate(armDx, armDy); this.drawBombShape(ctx); ctx.restore();
                }
            }
            drawEnemy(ctx) {
                ctx.strokeStyle = this.color; ctx.lineWidth = 4; ctx.lineCap = 'round';
                ctx.beginPath(); ctx.arc(0, -20, 10, 0, Math.PI * 2); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(0, 15); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, 15); ctx.lineTo(-10, 35); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, 15); ctx.lineTo(10, 35); ctx.stroke();
            }
            drawBombShape(ctx) {
                ctx.beginPath(); ctx.arc(0, 0, 14, 0, Math.PI * 2); ctx.fillStyle = '#2c3e50'; ctx.fill();
                ctx.beginPath(); ctx.moveTo(0, -12); ctx.quadraticCurveTo(8, -20, 12, -12); ctx.strokeStyle = '#e67e22'; ctx.lineWidth = 3; ctx.stroke();
            }
        }

        class Bomb extends Entity {
            constructor(x, y, vx, vy) {
                super(x, y, 'bomb', 'black');
                this.vx = vx; this.vy = vy;
                this.fuse = Date.now() + BOMB_FUSE;
            }
            update() {
                super.update();
                if (Date.now() >= this.fuse) this.explode();
            }
            explode() {
                this.markedForDeletion = true;
                gameState.cameraShake = 22;
                playSFX('explosion');
                for(let i=0; i<30; i++) {
                    gameState.particles.push({
                        x: this.x, y: this.y, vx: (Math.random()-0.5)*20, vy: (Math.random()-0.5)*20,
                        life: 1.0, decay: 0.02, color: '#e74c3c'
                    });
                }
                gameState.entities.forEach(ent => {
                    if (ent.type === 'stickman') {
                        const d = Math.hypot(ent.x - this.x, ent.y - this.y);
                        if (d < 185) {
                            const angle = Math.atan2(ent.y - this.y, ent.x - this.x);
                            const force = (185 - d) / 185 * 45;
                            ent.markedForDeletion = true;
                            playSFX('impact');
                            spawnPieces(ent.x, ent.y, angle, force);
                        }
                    }
                });
            }
        }

        function spawnPieces(x, y, angle, force) {
            for(let i=0; i<6; i++) {
                const p = new Entity(x, y, 'piece', '#d63031');
                const a = angle + (Math.random()-0.5);
                p.vx = Math.cos(a) * force * (0.6 + Math.random());
                p.vy = Math.sin(a) * force * (0.6 + Math.random()) - 10;
                p.rotVel = (Math.random()-0.5) * 4;
                gameState.entities.push(p);
            }
        }

        /**
         * EL TAKİBİ (MediaPipe Hands - Lite)
         */
        const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({ 
            maxNumHands: 1, 
            modelComplexity: 0, // Lite mod (Hızlı)
            minDetectionConfidence: 0.5, 
            minTrackingConfidence: 0.5 
        });

        function onResults(results) {
            document.getElementById('loading-overlay').style.display = 'none';
            const statusDot = document.getElementById('status-dot');
            const statusText = document.getElementById('status-text');

            previewCtx.save();
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            previewCtx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                gameState.handFound = true;
                statusDot.className = "w-3 h-3 rounded-full bg-green-500";
                statusText.innerText = "SİSTEM AKTİF";

                const lm = results.multiHandLandmarks[0];
                drawConnectors(previewCtx, lm, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 3});
                drawLandmarks(previewCtx, lm, {color: '#FF0000', lineWidth: 1, radius: 3});

                // Mapping
                const hX = 1 - lm[9].x; 
                const hY = lm[9].y;
                const player = gameState.entities.find(e => e.type === 'player');
                if (player) {
                    gameState.playerArmPos.x = player.x + (hX - 0.5) * 2 * MAX_ARM_RADIUS;
                    gameState.playerArmPos.y = (player.y - 8) + (hY - 0.5) * 2 * MAX_ARM_RADIUS;
                }

                // Klasik Yumruk Kontrolü (Parmak uçları eklemlerin altında mı?)
                const isFistNow = lm[8].y > lm[6].y && lm[12].y > lm[10].y;

                if (isFistNow && !gameState.isFist) {
                    gameState.isFist = true;
                    gameState.grabStartPos = { ...gameState.playerArmPos };
                    gameState.grabStartTime = Date.now();
                } else if (!isFistNow && gameState.isFist) {
                    launchBombAction();
                }
            } else {
                gameState.handFound = false;
                statusDot.className = "w-3 h-3 rounded-full bg-red-500 animate-pulse";
                statusText.innerText = "EL ARANIYOR";
            }
            previewCtx.restore();
        }

        function launchBombAction() {
            const dt = (Date.now() - gameState.grabStartTime) / 1000;
            const dx = gameState.playerArmPos.x - gameState.grabStartPos.x;
            const dy = gameState.playerArmPos.y - gameState.grabStartPos.y;
            
            if (dt > 0.05 && gameState.bombsLeft > 0) {
                const vx = (dx / dt) * 0.2;
                const vy = (dy / dt) * 0.2;
                if (Math.abs(vx) + Math.abs(vy) > 3.5) {
                    playSFX('throw');
                    gameState.bombsLeft--;
                    gameState.entities.push(new Bomb(gameState.playerArmPos.x, gameState.playerArmPos.y, vx, vy));
                    updateUI();
                    setTimeout(checkLevel, 3000);
                }
            }
            gameState.isFist = false;
        }

        hands.onResults(onResults);
        const camera = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 640, height: 480 });
        camera.start();

        /**
         * GAMEPLAY
         */
        function loadLevel(idx) {
            const levels = [
                { b: 5, e: [{x: 0.7, y: 0.8}, {x: 0.8, y: 0.8}, {x: 0.9, y: 0.8}] },
                { b: 4, e: [{x: 0.65, y: 0.5}, {x: 0.85, y: 0.5}] },
                { b: 3, e: [{x: 0.5, y: 0.8}, {x: 0.7, y: 0.6}, {x: 0.9, y: 0.4}] }
            ];
            if (idx >= levels.length) {
                showModal("EFSANE!", "Tüm stickman ordusunu yendin.", () => { gameState.level=1; loadLevel(0); });
                return;
            }
            const d = levels[idx];
            gameState.bombsLeft = d.b;
            gameState.entities = [new Entity(150, canvas.height - 100, 'player', '#2980b9')];
            gameState.entities[0].isStatic = true;
            d.e.forEach(e => gameState.entities.push(new Entity(canvas.width*e.x, canvas.height*e.y-50, 'stickman', '#c0392b')));
            updateUI();
        }

        function updateUI() {
            document.getElementById('level-display').innerText = gameState.level;
            document.getElementById('bomb-display').innerText = gameState.bombsLeft;
            const eCount = gameState.entities.filter(e => e.type === 'stickman').length;
            document.getElementById('enemy-display').innerText = eCount;
        }

        function checkLevel() {
            const enemies = gameState.entities.filter(e => e.type === 'stickman').length;
            if (enemies === 0) {
                showModal("TEBRİKLER!", "Harika bir atıştı.", () => { gameState.level++; loadLevel(gameState.level-1); });
            } else if (gameState.bombsLeft === 0 && !gameState.entities.some(e => e.type === 'bomb')) {
                showModal("BAŞARISIZ", "Bombalar bitti.", () => loadLevel(gameState.level-1));
            }
        }

        function showModal(t, d, a) {
            document.getElementById('modal-title').innerText = t;
            document.getElementById('modal-desc').innerText = d;
            document.getElementById('game-modal').classList.remove('hidden');
            document.getElementById('modal-btn').onclick = () => { document.getElementById('game-modal').classList.add('hidden'); a(); };
        }

        /**
         * RENDER LOOP
         */
        function loop() {
            const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
            g.addColorStop(0, '#74b9ff'); g.addColorStop(1, '#a29bfe');
            ctx.fillStyle = g; ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Sun
            ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(80, 80, 40, 0, Math.PI*2); ctx.fill();

            // Clouds
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            gameState.clouds.forEach(c => {
                c.x += c.speed; if(c.x > canvas.width + 100) c.x = -100;
                ctx.beginPath(); ctx.ellipse(c.x, c.y, c.size, c.size*0.4, 0, 0, Math.PI*2); ctx.fill();
            });

            // Mountains
            ctx.fillStyle = '#3ad968';
            gameState.mountains.forEach(m => {
                ctx.beginPath(); ctx.moveTo(m.x, canvas.height-50); ctx.lineTo(m.x+m.w/2, canvas.height-50-m.h); ctx.lineTo(m.x+m.w, canvas.height-50); ctx.fill();
            });

            let sx = 0, sy = 0;
            if(gameState.cameraShake > 0) {
                sx = (Math.random()-0.5)*gameState.cameraShake; sy = (Math.random()-0.5)*gameState.cameraShake;
                gameState.cameraShake *= 0.85;
            }

            ctx.save(); ctx.translate(sx, sy);
            ctx.fillStyle = '#27ae60'; ctx.fillRect(0, canvas.height-50, canvas.width, 50);

            for(let i=gameState.particles.length-1; i>=0; i--) {
                const p = gameState.particles[i];
                p.x += p.vx; p.y += p.vy; p.life -= p.decay;
                ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI*2); ctx.fill();
                if(p.life <= 0) gameState.particles.splice(i, 1);
            }
            ctx.globalAlpha = 1;

            gameState.entities.forEach(ent => { ent.update(); ent.draw(ctx); });
            gameState.entities = gameState.entities.filter(e => !e.markedForDeletion && e.y < canvas.height + 200);

            ctx.restore();
            requestAnimationFrame(loop);
        }

        window.onload = () => {
            resize();
            loadLevel(0);
            loop();
        };
    </script>
</body>
</html>